program
  // === ESTRUTURAS ANINHADAS E CASOS AVANÇADOS ===
  
  var int level;
  var int points;
  var int lives;
  var string player_name;
  var string status;
  var float health;
  var int damage;
  var int shield;
  
  // Simulação de um sistema de jogo
  player_name = "Hero";
  level = 10;
  points = 1500;
  lives = 3;
  health = 100;
  damage = 25;
  shield = 50;
  
  print("=== SISTEMA DE JOGO ===");
  print("Player:");
  print(player_name);
  print("Level:");
  print(level);
  
  // Condicionais aninhadas complexas (sistema de level up)
  if (points > 1000) {
    if (level < 20) {
      if (lives > 2) {
        print("Pode fazer level up!");
        level = level + 1;
        print("Novo level:");
        print(level);
        
        if (level > 15) {
          print("Level alto alcançado!");
          if (level == 20) {
            print("Level máximo!");
          }
        }
      }
    }
  }
  
  // Sistema de batalha com múltiplas condições
  var int enemy_health;
  var int enemy_damage;
  var int total_damage;
  
  enemy_health = 80;
  enemy_damage = 30;
  
  print("=== SISTEMA DE BATALHA ===");
  
  if (health > enemy_health) {
    print("Herói mais forte!");
    
    if (damage > enemy_damage) {
      print("Ataque superior!");
      total_damage = damage + shield;
      
      if (total_damage > enemy_health) {
        print("Vitória garantida!");
        points = points + 200;
        print("Pontos ganhos:");
        print(points);
      }
    }
  }
  
  // Expressões matemáticas aninhadas para cálculo de stats
  var int attack_power;
  var int defense_power;
  var int final_score;
  
  attack_power = (damage * level) + (points / 10);
  defense_power = (shield * health) / (level + 1);
  final_score = ((attack_power + defense_power) * lives) / (level * 2);
  
  print("=== STATS CALCULADAS ===");
  print("Poder de ataque:");
  print(attack_power);
  print("Poder de defesa:");
  print(defense_power);
  print("Score final:");
  print(final_score);
  
  // Sistema de rankings com condicionais aninhadas
  if (final_score > 1000) {
    if (level > 15) {
      if (lives >= 3) {
        status = "LEGEND";
        print("Status: LEGEND!");
        
        if (points > 2000) {
          print("Pontuação épica!");
          
          if (health == 100) {
            print("Saúde perfeita!");
            print("ACHIEVEMENT UNLOCKED!");
          }
        }
      }
    }
  }
  
  // Expressões com operadores mistos e aninhamento extremo
  var int complex_formula;
  complex_formula = (((level + points) * (health - damage)) / ((shield + lives) - (enemy_health / 10))) + (((attack_power * defense_power) / (final_score + 1)) * ((level * lives) + (points / 100)));
  
  print("Fórmula complexa resultado:");
  print(complex_formula);
  
  // Sistema de upgrade baseado em múltiplas condições
  var int upgrade_cost;
  var int can_upgrade;
  
  upgrade_cost = level * 100;
  can_upgrade = 0;
  
  if (points >= upgrade_cost) {
    if (level < 25) {
      if (health > 50) {
        can_upgrade = 1;
        print("Upgrade disponível!");
        
        // Aplicar upgrade
        if (can_upgrade == 1) {
          points = points - upgrade_cost;
          level = level + 1;
          health = health + 10;
          damage = damage + 5;
          
          print("Upgrade aplicado!");
          print("Novo level:");
          print(level);
          print("Nova health:");
          print(health);
          print("Novo damage:");
          print(damage);
          print("Pontos restantes:");
          print(points);
        }
      }
    }
  }
  
  // Condicionais com expressões aritméticas complexas
  if ((level * 2) + (points / 50) > (health + damage)) {
    if ((shield * lives) - (enemy_damage * 2) >= (level + 10)) {
      print("Condição matemática complexa atendida!");
      
      var int bonus;
      bonus = ((level * points) / (health + damage)) + ((shield * lives) * (final_score / 100));
      print("Bônus calculado:");
      print(bonus);
    }
  }
  
  // Final boss: expressão ultra aninhada
  var int ultimate_calculation;
  ultimate_calculation = ((((level * points) + (health * damage)) - ((shield + lives) * (enemy_health / 5))) * (((attack_power + defense_power) / (final_score + level)) + ((points * health) / (damage + shield)))) + (((level + lives) * (points + health)) - ((damage + shield) / (attack_power + 1)));
  
  print("=== CÁLCULO ULTIMATE ===");
  print(ultimate_calculation);
  
end;